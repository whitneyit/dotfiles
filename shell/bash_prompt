#!/usr/bin/env bash

# Determine if the git repo we are in has any changes in the working directory
function parse_git_dirty() {
    [[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]] && echo "*"
    # local git_status=$(git status 2> /dev/null | tail -n1)
    # [[ $git_status && $git_status != *"working directory clean"* ]] && echo "*"
}

# If the current directory belongs is a descendant of a git repo, determine the
# name of branch that is checked out
function parse_git_branch() {
    git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
    # echo "$(git rev-parse --abbrev-ref HEAD 2> /dev/null)""$(parse_git_dirty)"
}

# If we are in Cygwin or MING, we don't do any fancy color schemes.
if [ $(is_cygwin) == "no" ] && [ $(is_ming) == "no" ]; then

    # It seems that ChromeOS does not play nice with 256 colours. Until that is
    # resolved, it looks like we can't use 256 color mode there.
    if [ "$(is_chromeos)" == "no" ]; then

        # Set 256 color profile where possible
        if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
            export TERM=gnome-256color
        elif infocmp xterm-256color >/dev/null 2>&1; then
            export TERM=xterm-256color
        fi

    fi

    # Define some variables for our base16 theme
    export BASE16_THEME="ocean"
    export BASE16_VIM="base16-$BASE16_THEME"
    export BASE16_VARIANT="dark"
    export BASE16_FILE="base16-$BASE16_THEME.$BASE16_VARIANT.sh"
    export BASE16_DIRECTORY="$DOTFILES_DIRECTORY/shell/base16-shell"

    # When the active base16 theme is located
    export BASE16_ACTIVE_THEME_PATH="$BASE16_DIRECTORY/$BASE16_FILE"

    # Use the base16 colour scheme
    [[ -s $BASE16_ACTIVE_THEME_PATH ]] && source $BASE16_ACTIVE_THEME_PATH

    # Define the colours to use
    if tput setaf 1 &> /dev/null; then
        tput sgr0
        if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
            BLACK=$(tput setaf 0)
            MAGENTA=$(tput setaf 9)
            ORANGE=$(tput setaf 172)
            YELLOW=$(tput setaf 190)
            PURPLE=$(tput setaf 141)
            WHITE=$(tput setaf 255)
        else
            BLACK=$(tput setaf 0)
            RED=$(tput setaf 1)
            GREEN=$(tput setaf 2)
            YELLOW=$(tput setaf 3)
            BLUE=$(tput setaf 4)
            PURPLE=$(tput setaf 5)
            CYAN=$(tput setaf 6)
            WHITE=$(tput setaf 7)

            MAGENTA=$RED
            ORANGE=$GREEN

        fi
        BOLD=$(tput bold)
        RESET=$(tput sgr0)
    else
        BLACK="\033[1;30m"
        MAGENTA="\033[1;31m"
        ORANGE="\033[1;33m"
        GREEN="\033[1;32m"
        PURPLE="\033[1;35m"
        WHITE="\033[1;37m"
        BOLD=""
        RESET="\033[m"
    fi

else

    BLACK="\033[1;30m"
    MAGENTA="\033[1;31m"
    ORANGE="\033[1;33m"
    GREEN="\033[1;32m"
    PURPLE="\033[1;35m"
    WHITE="\033[1;37m"
    BOLD=""
    RESET="\033[m"

fi

export BLACK
export MAGENTA
export ORANGE
export GREEN
export PURPLE
export WHITE
export BOLD
export RESET

# Determine the look of our prompt. Eg
#
# whitneyit at MacBook in ~/Code/dotfiles on master
# $ echo "Hello world" > hi.txt
# whitneyit at MacBook in ~/Code/dotfiles on master*
# $
#
# If we are using MING, then we do nothing otherwise we set the $PS1
if [ $(is_ming) == "no" ]; then
    export PS1="\[${BOLD}${MAGENTA}\]\u \[$WHITE\]at \[$ORANGE\]\h \[$WHITE\]in \[$YELLOW\]\w\[$WHITE\]\$([[ -n \$(git branch 2> /dev/null) ]] && echo \" on \")\[$PURPLE\]\$(parse_git_branch)\[$WHITE\]\n\$ \[$RESET\]"
fi

# vim: set syn=sh :
